import { NextRequest, NextResponse } from "next/server";
import { getToken, requestOboToken } from "@navikt/oasis";
import { isLocalDev, createLocalDevToken } from "@/app/utils/localDevAuth";

interface VulnerabilitySearchResult {
  identifier: string;
  workloadName: string;
  workloadId: string;
  team: string;
  environment: string;
  repository?: string;
  riskScore: number;
  packageName: string;
}

function getServerEnv() {
  const tptBackendUrl = process.env.TPT_BACKEND_URL;
  const tptBackendScope = process.env.TPT_BACKEND_SCOPE;

  if (!tptBackendUrl) {
    throw new Error("TPT_BACKEND_URL not configured");
  }

  if (!isLocalDev() && !tptBackendScope) {
    throw new Error("TPT_BACKEND_SCOPE not configured");
  }

  return { tptBackendUrl, tptBackendScope };
}

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const query = searchParams.get("q");

  if (!query || query.trim().length === 0) {
    return NextResponse.json({ 
      results: [], 
      totalCount: 0 
    });
  }

  try {
    const { tptBackendUrl } = getServerEnv();

    let backendToken: string;

    if (isLocalDev()) {
      const email = process.env.LOCAL_DEV_EMAIL || "lokal.utvikler@nav.no";
      backendToken = createLocalDevToken(email);
    } else {
      const accessToken = getToken(request);
      if (!accessToken) {
        return NextResponse.json(
          { error: "Authentication required" },
          { status: 401 }
        );
      }

      const { tptBackendScope } = getServerEnv();
      const oboResult = await requestOboToken(accessToken, tptBackendScope!);

      if (!oboResult.ok) {
        console.error("Failed to get OBO token:", oboResult.error);
        return NextResponse.json(
          { error: "Failed to authenticate with backend" },
          { status: 500 }
        );
      }

      backendToken = oboResult.token;
    }

    // Fetch all vulnerabilities data
    const response = await fetch(
      `${tptBackendUrl}/api/vulnerabilities`,
      {
        headers: {
          Authorization: `Bearer ${backendToken}`,
        },
      }
    );

    if (!response.ok) {
      return NextResponse.json(
        { error: "Failed to fetch vulnerabilities" },
        { status: response.status }
      );
    }

    const data = await response.json();
    const results: VulnerabilitySearchResult[] = [];
    const searchLower = query.toLowerCase().trim();

    // Search through all teams and workloads
    if (data.teams && Array.isArray(data.teams)) {
      for (const team of data.teams) {
        if (team.workloads && Array.isArray(team.workloads)) {
          for (const workload of team.workloads) {
            if (workload.vulnerabilities && Array.isArray(workload.vulnerabilities)) {
              for (const vuln of workload.vulnerabilities) {
                // Search by identifier (CVE ID) or package name
                if (
                  vuln.identifier?.toLowerCase().includes(searchLower) ||
                  vuln.packageName?.toLowerCase().includes(searchLower)
                ) {
                  results.push({
                    identifier: vuln.identifier || "N/A",
                    workloadName: workload.name,
                    workloadId: workload.id,
                    team: team.team,
                    environment: workload.environment,
                    repository: workload.repository,
                    riskScore: vuln.riskScore || 0,
                    packageName: vuln.packageName || "N/A",
                  });
                }
              }
            }
          }
        }
      }
    }

    return NextResponse.json({
      results,
      totalCount: results.length,
    });
  } catch (error) {
    console.error("Error searching vulnerabilities:", error);
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}
