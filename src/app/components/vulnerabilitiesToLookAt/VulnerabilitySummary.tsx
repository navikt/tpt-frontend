"use client";
import { useVulnerabilities } from "../../hooks/useVulnerabilities";
import { useConfig } from "../../hooks/useConfig";
import { Box, HStack, VStack, Heading, BodyShort, Skeleton, Alert, Button, Tooltip } from "@navikt/ds-react";
import {
  CheckmarkCircleFillIcon,
  ExclamationmarkTriangleFillIcon,
  XMarkOctagonFillIcon,
  InformationSquareFillIcon,
  ArrowsCirclepathIcon,
} from "@navikt/aksel-icons";

export interface BucketThreshold {
  name: string;
  minThreshold: number;
  maxThreshold: number;
}

interface BucketData {
  name: string;
  count: number;
  color: string;
  bgColor: string;
  icon: React.ReactNode;
  minThreshold: number;
  maxThreshold: number;
}

interface VulnerabilitySummaryProps {
  selectedBucket: BucketThreshold;
  onBucketSelect: (bucket: BucketThreshold) => void;
}

const VulnerabilitySummary = ({ selectedBucket, onBucketSelect }: VulnerabilitySummaryProps) => {
  const { data, isLoading, isRefreshing, refresh, canRefresh, timeUntilRefresh } = useVulnerabilities();
  const { config, isLoading: configLoading } = useConfig();

  const formatTimeRemaining = (ms: number) => {
    const minutes = Math.ceil(ms / 60000);
    return `${minutes} min`;
  };

  const highThreshold = config?.thresholds.high ?? 150;
  const mediumThreshold = config?.thresholds.medium ?? 75;
  const lowThreshold = config?.thresholds.low ?? 30;

  // Calculate counts for each bucket
  const allVulnerabilities =
    data?.teams.flatMap((team) =>
      team.workloads.flatMap((workload) => workload.vulnerabilities)
    ) || [];

  const criticalCount = allVulnerabilities.filter(
    (v) => v.riskScore >= highThreshold
  ).length;

  const importantCount = allVulnerabilities.filter(
    (v) => v.riskScore >= mediumThreshold && v.riskScore < highThreshold
  ).length;

  const whenTimeCount = allVulnerabilities.filter(
    (v) => v.riskScore >= lowThreshold && v.riskScore < mediumThreshold
  ).length;

  const lowPriorityCount = allVulnerabilities.filter(
    (v) => v.riskScore < lowThreshold
  ).length;

  const totalCount = allVulnerabilities.length;

  const buckets: BucketData[] = [
    {
      name: "Høy prio",
      count: criticalCount,
      color: "var(--a-surface-danger)",
      bgColor: "var(--a-surface-danger-subtle)",
      icon: <XMarkOctagonFillIcon aria-hidden fontSize="1.5rem" style={{ color: "var(--a-surface-danger)" }} />,
      minThreshold: highThreshold,
      maxThreshold: Number.MAX_VALUE,
    },
    {
      name: "Lurt å ta unna",
      count: importantCount,
      color: "var(--a-surface-warning)",
      bgColor: "var(--a-surface-warning-subtle)",
      icon: <ExclamationmarkTriangleFillIcon aria-hidden fontSize="1.5rem" style={{ color: "var(--a-surface-warning)" }} />,
      minThreshold: mediumThreshold,
      maxThreshold: highThreshold,
    },
    {
      name: "Når du har tid",
      count: whenTimeCount,
      color: "var(--a-surface-info)",
      bgColor: "var(--a-surface-info-subtle)",
      icon: <InformationSquareFillIcon aria-hidden fontSize="1.5rem" style={{ color: "var(--a-surface-info)" }} />,
      minThreshold: lowThreshold,
      maxThreshold: mediumThreshold,
    },
    {
      name: "Lav prioritet",
      count: lowPriorityCount,
      color: "var(--a-surface-success)",
      bgColor: "var(--a-surface-success-subtle)",
      icon: <CheckmarkCircleFillIcon aria-hidden fontSize="1.5rem" style={{ color: "var(--a-surface-success)" }} />,
      minThreshold: 0,
      maxThreshold: lowThreshold,
    },
  ];

  const loading = isLoading || configLoading;

  if (loading) {
    return (
      <Box
        padding="6"
        borderRadius="medium"
        background="surface-subtle"
        style={{ marginBottom: "1.5rem" }}
      >
        <Skeleton variant="text" width="60%" height={32} />
        <div style={{ marginTop: "1rem" }}>
          <HStack gap="4" wrap>
            {[1, 2, 3, 4].map((i) => (
              <Skeleton key={i} variant="rounded" width={150} height={80} />
            ))}
          </HStack>
        </div>
      </Box>
    );
  }

  return (
    <Box
      padding="6"
      borderRadius="medium"
      background="surface-subtle"
      style={{ marginBottom: "1.5rem" }}
    >
      <VStack gap="4">
        {/* Header with refresh button */}
        <HStack justify="space-between" align="center">
          <Alert variant="warning" size="small" style={{ flex: 1 }}>
            Prioriteringen er basert på tilgjengelig informasjon. En sårbarhet kan være kritisk selv om den er lavt prioritert, for eksempel hvis den ikke er analysert ennå.
          </Alert>
          <Tooltip content={canRefresh ? "Hent nye data fra backend" : `Vent ${formatTimeRemaining(timeUntilRefresh)}`}>
            <Button
              variant="tertiary"
              size="small"
              icon={<ArrowsCirclepathIcon aria-hidden />}
              onClick={refresh}
              disabled={!canRefresh}
              loading={isRefreshing}
              style={{ marginLeft: "1rem" }}
            >
              Oppdater
            </Button>
          </Tooltip>
        </HStack>

        {/* Scatter plot graph showing risk score distribution */}
        {totalCount > 0 && (
          <Box
            padding="4"
            borderRadius="medium"
            background="surface-default"
            style={{ border: "1px solid var(--a-border-subtle)" }}
          >
            <VStack gap="2">
              <BodyShort size="small" weight="semibold">
                Risikofordeling ({totalCount} sårbarheter)
              </BodyShort>
              <div
                style={{
                  position: "relative",
                  width: "100%",
                  height: "80px",
                  padding: "0",
                }}
              >
                {/* Graph container */}
                <div
                  style={{
                    position: "relative",
                    width: "100%",
                    height: "100%",
                    border: "1px solid var(--a-border-default)",
                    borderRadius: "4px",
                    overflow: "hidden",
                  }}
                >
                  {/* Background sections with colors (only show sections with data) */}
                  <div style={{ position: "absolute", width: "100%", height: "100%" }}>
                    {(() => {
                      const minScore = Math.min(...allVulnerabilities.map((v) => v.riskScore));
                      const maxScore = Math.max(...allVulnerabilities.map((v) => v.riskScore));
                      const range = maxScore - minScore || 1;
                      const padPercent = 0.02; // 2% padding on each side
                      
                      // Scale threshold positions to account for padding
                      const scaleToChart = (score: number) => {
                        const normalized = (score - minScore) / range;
                        return normalized * (1 - 2 * padPercent) + padPercent;
                      };
                      
                      const sections = [];
                      
                      // High priority section (above highest relevant threshold)
                      if (maxScore >= highThreshold) {
                        const leftPos = (1 - scaleToChart(highThreshold)) * 100;
                        const rightPos = (1 - scaleToChart(maxScore)) * 100;
                        const width = leftPos - rightPos;
                        if (width > 0.5) {
                          sections.push(
                            <div
                              key="high"
                              style={{
                                position: "absolute",
                                left: `${rightPos}%`,
                                top: 0,
                                width: `${width}%`,
                                height: "100%",
                                backgroundColor: "var(--a-surface-danger-subtle)",
                                borderRight: "2px solid var(--a-surface-danger)",
                              }}
                            />
                          );
                        }
                      }
                      
                      // Medium priority section
                      if (maxScore >= mediumThreshold && minScore < highThreshold) {
                        const leftPos = (1 - scaleToChart(mediumThreshold)) * 100;
                        const rightPos = (1 - scaleToChart(highThreshold)) * 100;
                        const width = leftPos - rightPos;
                        if (width > 0.5) {
                          sections.push(
                            <div
                              key="medium"
                              style={{
                                position: "absolute",
                                left: `${rightPos}%`,
                                top: 0,
                                width: `${width}%`,
                                height: "100%",
                                backgroundColor: "var(--a-surface-warning-subtle)",
                                borderRight: "2px solid var(--a-surface-warning)",
                              }}
                            />
                          );
                        }
                      }
                      
                      // Low-medium priority section
                      if (maxScore >= lowThreshold && minScore < mediumThreshold) {
                        const leftPos = (1 - scaleToChart(lowThreshold)) * 100;
                        const rightPos = (1 - scaleToChart(mediumThreshold)) * 100;
                        const width = leftPos - rightPos;
                        if (width > 0.5) {
                          sections.push(
                            <div
                              key="lowMed"
                              style={{
                                position: "absolute",
                                left: `${rightPos}%`,
                                top: 0,
                                width: `${width}%`,
                                height: "100%",
                                backgroundColor: "var(--a-surface-info-subtle)",
                                borderRight: "2px solid var(--a-surface-info)",
                              }}
                            />
                          );
                        }
                      }
                      
                      // Low priority section
                      if (minScore < lowThreshold) {
                        const pos1 = (1 - scaleToChart(lowThreshold)) * 100;
                        const leftPos = Math.max(pos1, 100); // Extend to right edge
                        const rightPos = Math.min(pos1, 100);
                        const width = leftPos - rightPos;
                        if (width > 0.5) {
                          sections.push(
                            <div
                              key="low"
                              style={{
                                position: "absolute",
                                left: `${rightPos}%`,
                                top: 0,
                                width: `${width}%`,
                                height: "100%",
                                backgroundColor: "var(--a-surface-success-subtle)",
                              }}
                            />
                          );
                        }
                      }
                      
                      return sections;
                    })()}
                  </div>
                  
                  {/* Dots for each vulnerability (aggregated by score) */}
                  <div style={{ position: "absolute", width: "100%", height: "100%" }}>
                    {(() => {
                      const minScore = Math.min(...allVulnerabilities.map((v) => v.riskScore));
                      const maxScore = Math.max(...allVulnerabilities.map((v) => v.riskScore));
                      const range = maxScore - minScore || 1;
                      
                      const scoreCounts = allVulnerabilities.reduce<Record<number, number>>((acc, vuln) => {
                        acc[vuln.riskScore] = (acc[vuln.riskScore] || 0) + 1;
                        return acc;
                      }, {});
                      const entries = Object.entries(scoreCounts)
                        .map(([score, count]) => ({ score: Number(score), count }))
                        .sort((a, b) => b.score - a.score);
                      
                      // Calculate positions for all dots (for line drawing)
                      const dotPositions = entries.map((entry, idx) => {
                        const normalizedPos = (entry.score - minScore) / range;
                        const paddedPos = normalizedPos * 0.96 + 0.02;
                        const xPercent = 100 - paddedPos * 100;
                        const yPercent = entries.length === 1 ? 50 : (idx / (entries.length - 1)) * 80 + 10;
                        return { x: xPercent, y: yPercent };
                      });
                      
                      // Create SVG path for connecting line
                      let pathData = "";
                      if (dotPositions.length > 0) {
                        // Convert percentage positions to SVG coordinates (assuming container is 100% width/height)
                        const points = dotPositions.map(pos => ({
                          x: pos.x,
                          y: pos.y,
                        }));
                        
                        // Start at first point
                        pathData = `M ${points[0].x} ${points[0].y}`;
                        
                        // Create smooth curve through all points using quadratic Bezier curves
                        for (let i = 1; i < points.length; i++) {
                          const prev = points[i - 1];
                          const curr = points[i];
                          const next = i + 1 < points.length ? points[i + 1] : curr;
                          
                          // Control point is the average of current and next point
                          const cpx = (curr.x + next.x) / 2;
                          const cpy = (curr.y + next.y) / 2;
                          
                          pathData += ` Q ${curr.x} ${curr.y} ${cpx} ${cpy}`;
                        }
                      }
                      
                      return (
                        <>
                          {/* SVG line connecting the dots */}
                          {dotPositions.length > 1 && (
                            <svg
                              style={{
                                position: "absolute",
                                width: "100%",
                                height: "100%",
                                top: 0,
                                left: 0,
                                pointerEvents: "none",
                              }}
                              viewBox="0 0 100 100"
                              preserveAspectRatio="none"
                            >
                              <path
                                d={pathData}
                                stroke="rgba(0, 0, 0, 0.15)"
                                strokeWidth="1.5"
                                fill="none"
                                strokeLinecap="round"
                                strokeLinejoin="round"
                              />
                            </svg>
                          )}
                          
                          {/* Dots */}
                          {entries.map((entry, idx) => {
                            const pos = dotPositions[idx];
                            const size = Math.min(6 + entry.count * 2, 18);
                            let color = "var(--a-surface-success)";
                            if (entry.score >= highThreshold) {
                              color = "var(--a-surface-danger)";
                            } else if (entry.score >= mediumThreshold) {
                              color = "var(--a-surface-warning)";
                            } else if (entry.score >= lowThreshold) {
                              color = "var(--a-surface-info)";
                            }
                            return (
                              <Tooltip key={`${entry.score}-${entry.count}-${idx}`} content={`Risikoscore: ${entry.score}${entry.count > 1 ? ` (${entry.count} sårbarheter)` : ""}`}>
                                <div
                                  style={{
                                    position: "absolute",
                                    left: `${pos.x}%`,
                                    top: `${pos.y}%`,
                                    width: `${size}px`,
                                    height: `${size}px`,
                                    borderRadius: "50%",
                                    backgroundColor: color,
                                    border: "1px solid rgba(255,255,255,0.5)",
                                    boxShadow: "0 1px 2px rgba(0,0,0,0.2)",
                                    transform: "translate(-50%, -50%)",
                                    cursor: "pointer",
                                    zIndex: 1,
                                  }}
                                />
                              </Tooltip>
                            );
                          })}
                        </>
                      );
                    })()}
                  </div>
                </div>
              </div>
            </VStack>
          </Box>
        )}

        {/* Bucket cards */}
        <HStack gap="4" wrap>
          {buckets.map((bucket, index) => {
            const isSelected = selectedBucket.name === bucket.name;
            const isCritical = bucket.name === "Høy prio";
            return (
              <Box
                key={index}
                padding={isCritical ? "5" : "3"}
                borderRadius="medium"
                onClick={() => onBucketSelect({ 
                  name: bucket.name, 
                  minThreshold: bucket.minThreshold, 
                  maxThreshold: bucket.maxThreshold 
                })}
                style={{
                  backgroundColor: bucket.bgColor,
                  border: isSelected ? `3px solid ${bucket.color}` : "1px solid var(--a-border-subtle)",
                  minWidth: isCritical ? "180px" : "140px",
                  flex: isCritical ? "1.5 1 180px" : "1 1 140px",
                  maxWidth: isCritical ? "250px" : "200px",
                  cursor: "pointer",
                  transition: "border 0.2s ease, transform 0.2s ease",
                  opacity: isCritical ? 1 : 0.75,
                  transform: isCritical ? "scale(1)" : "scale(0.95)",
                }}
              >
                <HStack gap="2" align="center">
                  {bucket.icon}
                  <VStack gap="0">
                    <BodyShort size={isCritical ? "medium" : "small"} weight="semibold">
                      {bucket.name}
                    </BodyShort>
                    <Heading size={isCritical ? "large" : "small"}>{bucket.count}</Heading>
                  </VStack>
                </HStack>
              </Box>
            );
          })}
        </HStack>
      </VStack>
    </Box>
  );
};

export default VulnerabilitySummary;
